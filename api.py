from flask import Flask, request, render_template
import joblib
import hashlib
import numpy as np
from sklearn.preprocessing import MinMaxScaler
from flask_wtf import FlaskForm
from wtforms import StringField, SubmitField
from wtforms.csrf.session import SessionCSRF
from flask_wtf.csrf import CSRFProtect

app = Flask(__name__)
app.config['SECRET_KEY'] = 'your_secret_key'  # Replace with your own secret key

# Initialize CSRF protection
csrf = CSRFProtect(app)

# Load the trained model and vectorizer
model = joblib.load('trained_model.pkl')
vectorizer = joblib.load('trained_vectorizer.pkl')

# Load the pre-fitted MinMaxScaler
scaler = joblib.load('trained_scaler.pkl')  # Make sure to save the scaler during training

class MD5Form(FlaskForm):
    md5_input = StringField('Enter MD5 Hash')
    submit = SubmitField('Predict')

@app.route('/')
def index():
    form = MD5Form()
    return render_template('index.html', form=form, prediction=None)

@app.route('/predict', methods=['POST'])
def predict():
    form = MD5Form()

    if form.validate_on_submit():
        md5_hash = form.md5_input.data

        # Convert the MD5 hash into numerical features using the same preprocessing as in training
        numeric_feature = int(hashlib.sha256(md5_hash.encode()).hexdigest(), 16)
        numeric_feature = np.array(numeric_feature).reshape(1, -1)  # Reshape the feature

        # Scale the numeric feature using the pre-fitted scaler
        numeric_feature = scaler.transform(numeric_feature)

        # Perform TF-IDF vectorization using the same vectorizer as in training
        text_feature = vectorizer.transform([md5_hash])

        # Combine the numeric and text features
        combined_feature = np.hstack((numeric_feature, text_feature.toarray()))

        # Make a prediction using the loaded model
        prediction = model.predict(combined_feature)

        return render_template('index.html', form=form, prediction=int(prediction[0]))
     

if __name__ == '__main__':
    app.run(port=5000)
